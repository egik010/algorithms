# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах
# в рамках первых трех уроков. Проанализировать результат и определить программы
# с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# ● выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# ● написать 3 варианта кода (один у вас уже есть);
# ● проанализировать 3 варианта и выбрать оптимальный;
# ● результаты анализа (количество занятой памяти в вашей среде разработки)
# вставить в виде комментариев в файл с кодом. Не забудьте указать версию
# и разрядность вашей ОС и интерпретатора Python;
# ● написать общий вывод: какой из трёх вариантов лучше и почему.
# Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof
# после каждой переменной, а проявили творчество, фантазию и создали универсальный код для замера памяти.

# выбрал 4 задачу из 3 домашнего задания
# Определить, какое число в массиве встречается чаще всего.
# Python 3.8.5 [MSC v.1926 32 bit (Intel)] on win32

import random
import timeit
import cProfile
import sys

SIZE = 10
MIN_ITEM = 0
MAX_ITEM = 10
arr = [random.randint(MIN_ITEM, MAX_ITEM // 2) for _ in range(SIZE)]


# print(arr)


def my_max_mem(array):
    # переберем ммассив и создадим словарь, в котором ключ это элемент массива, а значение - количество вхождений
    d = {}
    for line in array:
        if line not in d.keys():
            d[line] = 1
        else:
            d[line] = d[line] + 1
    # print(d)

    # теперь найдет в словаре максимальное количество вхождений
    max_ar = 0
    max_num = 0
    for i in d:
        if max_ar < d[i]:
            max_ar = d[i]
            max_num = i
    return max_num, locals()  # тут единственная модификация


def my_max_for(array):  # сделаем двойным for
    num = array[0]
    max_frq = 1
    for i in range(len(array) - 1):
        frq = 1
        for k in range(i + 1, len(array)):
            if array[i] == array[k]:
                frq += 1
        if frq > max_frq:
            max_frq = frq
            num = array[i]
    # это только для проверки!!!!
    # print('1-ая', sys.getsizeof(num) + sys.getsizeof(array) + sys.getsizeof(frq) + sys.getsizeof(max_frq) + sys.getsizeof(
    #     max_frq) + + sys.getsizeof(max_frq))
    # print(array)
    return num, locals()  # тут единственная модификация


def my_max_count(array):  # используем функцию count
    num = array[0]
    max_frq = 1
    for i in range(len(array) - 1):
        if array.count(array[i]) > max_frq:
            max_frq = array.count(array[i])
            num = array[i]
    return num, locals()  # тут единственная модификация


def my_sum(sum_data):
    z = 0
    for k, item in sum_data.items():
        z += sys.getsizeof(item)
    return z


_, ii = my_max_mem(arr)
print('Вариант с словарями было задействовано помяти: ', my_sum(ii))
_, ii = my_max_for(arr)
print('Вариант со всложенными for было задействовано помяти: ', my_sum(ii))
_, ii = my_max_count(arr)
print('Вариант с count было задействовано помяти: ', my_sum(ii))

# замеры:
# SIZE = 1000
# MIN_ITEM = 0
# MAX_ITEM = 1000
# Вариант с словарями было задействовано помяти:  14856
# Вариант со всложенными for было задействовано помяти:  4578
# Вариант с count было задействовано помяти:  4550

# SIZE = 1000
# MIN_ITEM = 0
# MAX_ITEM = 100
# Вариант с словарями было задействовано помяти:  5772
# Вариант со всложенными for было задействовано помяти:  4578
# Вариант с count было задействовано помяти:  4550

# SIZE = 5000
# MIN_ITEM = 0
# MAX_ITEM = 100
# Вариант с словарями было задействовано помяти:  22780
# Вариант со всложенными for было задействовано помяти:  21586
# Вариант с count было задействовано помяти:  21558

# SIZE = 1000
# MIN_ITEM = 0
# MAX_ITEM = 5000
# Вариант с словарями было задействовано помяти:  25100
# Вариант со всложенными for было задействовано помяти:  4578
# Вариант с count было задействовано помяти:  4550

# ******ИТОГОВЫЙ ВЫВОД!!!!!!!!!!!!!!!!!!
# Вариант 1 со словарем оправдывает себя по скорости, но  начинает кушать все больше памяти
# если эелементы списка все больше разняться - значения от MIN_ITEM до MAX_ITEM
# разница 2 и 3 варинат почти одинаковы по затратам пямяти, разница только в скорости

# на всякий вспомним ВЫВОДЫ по скорости:
# с использование дополнтительного словаря самый быстрый
# Вложенные циклы самые меделенные
# SIZE = 1000
# print(timeit.timeit('my_max_mem(arr)', number=100, globals=globals()))      #0.022524535
# print(timeit.timeit('my_max_for(arr)', number=100, globals=globals()))      #8.100276138
# print(timeit.timeit('my_max_count(arr)', number=100, globals=globals()))    #1.9094617539999987
